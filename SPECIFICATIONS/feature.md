# Technical Specifications: Bash Script Commenting Engine

This document outlines the technical specifications for the logic used to analyze and insert documentation into Bash scripts.

## 1. File and Function Identification

### 1.1. Target File Identification
The system processes files matching the patterns `utils.sh` and `*.utils.sh` within the `scripts/` directory. This is based on the initial task requirement to focus on these specific utility script naming conventions.

### 1.2. Function Identification
Functions are identified using a regular expression that matches common Bash function declaration syntaxes. The engine scans each file line by line to find matches for the following patterns:

-   `function_name() {` (with or without the `function` keyword)
-   `function function_name {` (less common, but supported)

Once a line is matched, the string preceding the `()` or `{` is extracted as the function name. This name is then used for generating the function-specific documentation.

## 2. Header Generation Logic

### 2.1. File Header Generation
The file header is generated through a combination of a static template and dynamic analysis of the entire script's content.

-   **Author/Email**: These fields are populated with the static values provided in the project constraints: `jmrenouard/jean-Marie Renouard` and `jmrenouard@lightpath.fr`.

-   **Description**: The description is synthesized by performing a high-level analysis of the script. The process involves:
    1.  **Keyword Analysis**: Scanning the script for keywords related to specific technologies (e.g., `mysql`, `mongo`, `psql`, `galera`, `lvm`, `ssh`, `docker`).
    2.  **Function Name Analysis**: Aggregating function names (e.g., `backup`, `restore`, `status`, `create_user`, `check_`, `test_`) to infer the script's primary capabilities.
    3.  **Content Synthesis**: Combining the identified technologies and capabilities into a coherent, human-readable paragraph that summarizes the script's overall purpose as a utility library.

-   **Usage**: For utility scripts that are intended to be sourced rather than executed directly, the `Usage` section is standardized to `source <script_name.sh>`. This determination is made if the script does not contain a main execution block or argument parsing logic (like `getopts`) at the top level.

-   **Examples**: Example use cases are generated by selecting a few representative functions from the script. The selection prioritizes functions that demonstrate core functionalities, such as:
    -   A simple status check (`mongo_status`).
    -   A command to list resources (`db_list`).
    -   An action with parameters (`mongo_backup "uri" "db"`).
    This provides a practical overview of how to use the script after sourcing it.

### 2.2. Function Header Generation
Each function header is generated by analyzing the code within that function's block (from `{` to the matching `}`).

-   **Description**: The function's purpose is inferred from its name (e.g., `to_lower` converts to lowercase) and the primary commands it executes (e.g., a function calling `mongodump` is for backups). The description details what the function does, its main purpose, and any important side effects or dependencies (like requiring `jq`).

-   **Arguments**: Argument analysis is performed by scanning the function's body for the usage of positional parameters (`$1`, `$2`, `$*`, etc.).
    -   The code surrounding each parameter is analyzed to infer its purpose. For example, if `$1` is used in `psql -p $1`, it is inferred to be a port number. If `$2` is used as a filename in `> "$2"`, it is an output file path.
    -   Default values are explicitly identified from patterns like `local l_var=${1:-"default"}`, which indicates an optional argument with a default value.
    -   The use of `shift` is tracked to correctly associate subsequent positional parameters with their intended purpose.

-   **Outputs**: The analysis for outputs is based on several indicators:
    -   **stdout**: The `echo` command is the primary indicator. The text or variable being echoed is analyzed to describe the output format.
    -   **stderr**: Redirections to `stderr` (`>&2`) are noted, especially in logging functions like `error` and `warn`.
    -   **Return Codes**: The `return` command is analyzed. `return 0` is documented as success, while other values are noted as failure or specific status codes. The pattern `return $?` is interpreted as returning the exit code of the last command.
    -   **File System Interaction**: Commands like `> file`, `>> file`, `mkdir`, `rm`, and `tar` are identified to describe how the function creates, modifies, or deletes files and directories.
    -   **Global Variables**: The use of `export` or `eval "export ..."` is tracked to document functions that set or modify environment variables as a side effect.

This multi-faceted approach of static and contextual analysis allows for the automated generation of detailed and accurate documentation that reflects the true behavior of each script and its functions.
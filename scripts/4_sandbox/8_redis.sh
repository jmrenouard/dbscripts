#!/usr/bin/env bash

# --- Minimal Utility Functions ---
now() { echo "$(date "+%F %T %Z")($(hostname -s))"; }
info() { echo "$(now) INFO: $*" 1>&2; }
error() { echo "$(now) ERROR: $*" 1>&2; return 1; }
ok() { info "[SUCCESS] $* [SUCCESS]"; }
sep1() { echo "$(now) -----------------------------------------------------------------------------"; }
title1() { sep1; echo "$(now) $*"; sep1; }
cmd() {
    local tcmd="$1"
    local descr=${2:-"$tcmd"}
    title1 "RUNNING: $descr"
    eval "$tcmd"
    local cRC=$?
    if [ $cRC -eq 0 ]; then
        ok "$descr"
    else
        error "$descr (RC=$cRC)"
    fi
    return $cRC
}
banner() { title1 "START: $*"; info "run as $(whoami)@$(hostname -s)"; }
footer() {
    local lRC=${lRC:-"$?"}
    info "FINAL EXIT CODE: $lRC"
    [ $lRC -eq 0 ] && title1 "END: $* SUCCESSFUL" || title1 "END: $* FAILED"
    return $lRC
}
# --- End of Utility Functions ---

_NAME="$(basename "$(readlink -f "$0")")"
NAME="${_NAME}"
lRC=0


generate_generic_service_file()
{
systemctl disable redis-server@.service
systemctl daemon-reload

  echo "[Unit]
Description=Advanced key-value store - Instance %i
After=network.target
Documentation=http://redis.io/documentation, man:redis-server(1)
#PartOf=redis.target

[Service]
Type=notify
ExecStart=/usr/bin/redis-server /etc/redis/redis-%i.conf
ExecStop=/bin/kill -s TERM $MAINPID
PIDFile=/run/redis/redis-server-%i.pid
TimeoutStopSec=0
Restart=always
User=redis
Group=redis
RuntimeDirectory=redis-%i
RuntimeDirectoryMode=2755

UMask=007
PrivateTmp=yes
LimitNOFILE=65535
PrivateDevices=yes
ProtectHome=yes
ReadOnlyDirectories=/
ReadWriteDirectories=-/var/lib/redis-%i
ReadWriteDirectories=-/var/log/redis
ReadWriteDirectories=-/run/redis

NoNewPrivileges=true
CapabilityBoundingSet=CAP_SETGID CAP_SETUID CAP_SYS_RESOURCE
RestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX
MemoryDenyWriteExecute=true
ProtectKernelModules=true
ProtectKernelTunables=true
ProtectControlGroups=true
RestrictRealtime=true
RestrictNamespaces=true

# redis-server can write to its own config file when in cluster mode so we
# permit writing there by default. If you are not using this feature, it is
# recommended that you replace the following lines with "ProtectSystem=full".
ProtectSystem=true
ReadWriteDirectories=-/etc/redis

[Install]
WantedBy=multi-user.target
Alias=redis_%i.service
" > /lib/systemd/system/redis-server@.service

systemctl disable redis-server@.service
systemctl daemon-reload
systemctl enable redis-server@.service
}

generate_generic_redis_conf_file()
{
  echo '# Network ip to bind
bind %addr%

# Listen port
port %port%

# We dont restrict bind to loopback device
protected-mode no

# We use only RDB file (snapshot)
# Cluster config
appendonly yes

# Use RDB compression
rdbcompression yes
#rdbcompression no

# Add checksum
rdbchecksum yes
#rdbchecksum no

# RDB configuration to do snapshot
save 900 1
save 300 10
save 60 10000

# If error occure when Redis try save data to disk, the node switch to read-only mode
stop-writes-on-bgsave-error yes

# In our case use only 1 database
databases 1

# Show logo on statup, in log, its easy to see when Redis restart
always-show-logo yes

# By default, log level is notice
loglevel notice

# Filename of database. This file is in 'dir' folder
dbfilename "dump.rdb"

# Folder configuration
pidfile %pid%
logfile %log%
dir %dir%

# Cluster
cluster-enabled yes
# This file is automatically generated by Redis on each node to remember configuration of cluster
cluster-config-file nodes.conf
cluster-node-timeout 5000

# Systemd
daemonize no
supervised systemd

# Tuning
# tcp-keepalive 0
# maxmemory-policy  volatile-lru
# maxmemory 1512M
# timeout 3000
# rdbcompression no
# rdbchecksum no' > /etc/redis/redis.conf.tpl
}

cleanup_cluster()
{
  systemctl stop redis-server@$1
  rm -rf /var/lib/redis-server-$1/*
  rm -f ${BASEDIR}/nodes.conf
  touch ${BASEDIR}/nodes.conf
  chown redis: touch ${BASEDIR}/nodes.conf
  systemctl start redis-server@$1
  systemctl status redis-server@$1
}

# $1 : redis port
# $2 : output file
# $3 : username
# $4 : ip addresse
# $5 : working directory
# $6 : log file
# $7 : pid file
generate_config_file() {
  BASEDIR="/etc/redis"
  perl -pe "s#%port%#$1#g;s#%addr%#$4#g;s#%dir%#$5#g;s#%log%#$6#g;s#%pid%#$7#g" ${BASEDIR}/redis.conf.tpl > ${BASEDIR}/$2
  touch ${BASEDIR}/nodes.conf
  set -x 
  mkdir -p $5
  chmod 750 $5
  chown -R $3:$3 ${BASEDIR}/$2 $5 ${BASEDIR}/nodes.conf

  cat ${BASEDIR}/$2
  ls -lsh $(dirname $5) | grep $(basename $5)
  ls -lsh $5

}



# IP -> empty not found
find_ip() {
  IP=""

  for ip in $(hostname -I); do
    the_ip=$(echo ${ip} | grep '194.5')

    if [ -n "${the_ip}" ]; then
      IP="${the_ip}"
      return 0
    fi
  done
}

instal_redis_packages()
{
	add-apt-repository ppa:redislabs/redis
	apt-get update
	apt-get install -y redis pwgen net-tools
}

system_tuning_redis()
{
	echo "net.core.somaxconn=65365
vm.overcommit_memory = 1" > /etc/sysctl.d/redis.conf

echo never > /sys/kernel/mm/transparent_hugepage/enabled
}

config_cluster_settings()
{
tmpFile=$(mktemp)
(
echo "#!/bin/env bash

redis-cli --cluster create \\"
for srv in $server_ips;do
   for port in $server_ports; do
      echo  -n "$srv:$port "
   done
   echo "\\"
done
echo "--cluster-replicas 2"
) > $tmpFile

if [ "$debug" = "true" ]; then
  cat $tmpFile
else
  bash -x $tmpfile
fi
rm -f $tmpFile
}

reset_redis_cluster()
{
tmpFile=$(mktemp)
(
echo "#!/bin/env bash

for srv in $server_ips;do
   for port in $server_ports; do
       echo 'CLUSTER RESET HARD' | redis-cli --verbose -h \$srv -p \$port
   done
done
) > $tmpFile

if [ "$debug" = "true" ]; then
  cat $tmpFile
else
  bash -x $tmpfile
fi
rm -f $tmpFile
}

set_password()
{
  local pass=${1:-"$(pwgen -1 18)"}
 tmpFile=$(mktemp)
(
echo "#!/bin/env bash

for srv in $server_ips;do
  for port in $server_ports; do
    redis-cli -h \$srv -p \$port config set requirepass $pass
    redis-cli -a $pass -h \$srv -p \$port config set masterauth $pass
    redis-cli -a $pass -h \$srv -p \$port config rewrite
   done
done
) > $tmpFile

if [ "$debug" = "true" ]; then
  cat $tmpFile
else
bash -x $tmpfile
fi
rm -f $tmpFile
}

export server_ips=${server_ips:"10.45.80.72 10.45.80.71 10.45.80.73"}
export server_ports="${server_ports:-"$(seq 6379 6381)"}

export my_private_ipv4=$(ip a | grep inet | grep 'brd' | grep '192.168'| cut -d/ -f1 | awk '{print $2}' | head -n 1)
export my_public_ipv4=$(ip a | grep inet | grep 'brd' | grep -v '192.168'| cut -d/ -f1 | awk '{print $2}' | head -n 1)


if [ "$1" = "install" ]; then

banner "BEGIN SCRIPT: ${_NAME}"

instal_redis_packages
lRC=$(($lRC + $?))

system_tuning_redis
lRC=$(($lRC + $?))

generate_generic_redis_conf_file
generate_generic_service_file

cmd "systemctl stop redis-server"
cmd "systemctl disable redis-server"

cleanup_cluster cluster1
cleanup_cluster cluster2
cleanup_cluster cluster3

generate_config_file 6379 redis-cluster1.conf redis $my_public_ipv4 /var/lib/redis-cluster1 /var/log/redis/redis-server-cluster1.log /var/run/redis/redis-server-cluster1.pid
generate_config_file 6380 redis-cluster2.conf redis $my_public_ipv4 /var/lib/redis-cluster2 /var/log/redis/redis-server-cluster2.log /var/run/redis/redis-server-cluster2.pid
generate_config_file 6381 redis-cluster3.conf redis $my_public_ipv4 /var/lib/redis-cluster3 /var/log/redis/redis-server-cluster3.log /var/run/redis/redis-server-cluster3.pid

cmd "systemctl start redis-server@cluster1 redis-server@cluster2 redis-server@cluster3"
cmd "systemctl status redis-server@cluster1 redis-server@cluster2 redis-server@cluster3"

config_cluster_settings
lRC=$(($lRC + $?))

footer "END SCRIPT: ${_NAME}"
fi
exit $lRC